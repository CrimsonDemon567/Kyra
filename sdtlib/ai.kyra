# ---------------------------
# Weighted Choice
# ---------------------------

def choose_weighted(items, weights):
    total = 0
    i = 0
    while i < len(weights):
        total = total + weights[i]
        i = i + 1

    if total == 0:
        return items[0]

    r = randfloat() * total

    i = 0
    while i < len(weights):
        if r < weights[i]:
            return items[i]
        r = r - weights[i]
        i = i + 1

    return items[len(items) - 1]

# ---------------------------
# Finite State Machine
# ---------------------------

def fsm(initial):
    return {
        "state": initial,
        "transitions": {}
    }

def add_transition(f, from_state, event, to_state):
    key = from_state + ":" + event
    f["transitions"][key] = to_state

def trigger(f, event):
    key = f["state"] + ":" + event
    if key in f["transitions"]:
        f["state"] = f["transitions"][key]
    return f["state"]

# ---------------------------
# Utility Scoring
# ---------------------------

def best_choice(options, scores):
    if len(options) == 0:
        return ""

    best = options[0]
    best_score = scores[0]

    i = 1
    while i < len(options):
        if scores[i] > best_score:
            best = options[i]
            best_score = scores[i]
        i = i + 1

    return best
